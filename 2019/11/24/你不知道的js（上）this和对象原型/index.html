<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="你不知道的js,javascript," />










<meta name="description" content="第一章 关于thisthis是用于传递上下文对象的一种机制。 this的绑定和函数声明为u管，只取决于函数的调用方式。this实在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this绑定的4种情况 foo() 默认绑定，this指向全局对象（window）, 严格模式下，this指向undefined  obj.foo() 隐式绑定，this指向obj  12&#x2F;&#x2F;隐式绑定很容易">
<meta name="keywords" content="你不知道的js,javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="你不知道的js（上）- this和对象原型">
<meta property="og:url" content="http:&#x2F;&#x2F;blog.eatcode.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%EF%BC%89this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B&#x2F;index.html">
<meta property="og:site_name" content="Lory&#39;s Notes">
<meta property="og:description" content="第一章 关于thisthis是用于传递上下文对象的一种机制。 this的绑定和函数声明为u管，只取决于函数的调用方式。this实在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this绑定的4种情况 foo() 默认绑定，this指向全局对象（window）, 严格模式下，this指向undefined  obj.foo() 隐式绑定，this指向obj  12&#x2F;&#x2F;隐式绑定很容易">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;blog.eatcode.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%EF%BC%89this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B&#x2F;%E7%B1%BB.png">
<meta property="og:image" content="http:&#x2F;&#x2F;blog.eatcode.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%EF%BC%89this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B&#x2F;%E5%A4%9A%E6%80%81.png">
<meta property="og:updated_time" content="2019-11-24T05:56:46.610Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;blog.eatcode.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%EF%BC%89this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B&#x2F;%E7%B1%BB.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.eatcode.com/2019/11/24/你不知道的js（上）this和对象原型/"/>





  <title>你不知道的js（上）- this和对象原型 | Lory's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lory's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.eatcode.com/2019/11/24/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%EF%BC%89this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lory">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lory's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">你不知道的js（上）- this和对象原型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-24T13:44:39+08:00">
                2019-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/books/" itemprop="url" rel="index">
                    <span itemprop="name">books</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="第一章-关于this"><a href="#第一章-关于this" class="headerlink" title="第一章 关于this"></a>第一章 关于this</h4><p>this是用于传递上下文对象的一种机制。</p>
<p>this的绑定和函数声明为u管，只取决于函数的调用方式。this实在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>
<h5 id="this绑定的4种情况"><a href="#this绑定的4种情况" class="headerlink" title="this绑定的4种情况"></a><font color="LightCoral">this绑定的4种情况</font></h5><ol>
<li><p>foo()</p>
<p>默认绑定，this指向全局对象（window）, 严格模式下，this指向undefined</p>
</li>
<li><p>obj.foo()</p>
<p>隐式绑定，this指向obj </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//隐式绑定很容易脱绑，bar此时指向的foo函数本身</span><br><span class="line">var bar = obj.foo()</span><br></pre></td></tr></table></figure>
</li>
<li><p>foo.call(obj)</p>
<p>foo.apply(obj)</p>
<p>foo.bind(obj)</p>
<ul>
<li>⭐<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind实现</a></li>
</ul>
<p>显示绑定，this被强绑定为obj</p>
</li>
<li><p>var bar = new foo() </p>
<p>this 指向新创建的对象</p>
<blockquote>
<p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建（或者说构造）一个全新的对象。 </li>
<li>这个新对象会被执行 [[ 原型 ]] 连接。 </li>
<li>这个新对象会绑定到函数调用的 this。 </li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ol>
</blockquote>
</li>
</ol>
<h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt;默认绑定</p>
<h5 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h5><p>把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 2</span><br><span class="line">//null被忽略，this为window</span><br><span class="line">foo.call(null)</span><br></pre></td></tr></table></figure>

<p>🙃 注：使用null忽略this的方式有可能会造成修改全局对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">	//修改全局变量</span><br><span class="line">	this.a = 2</span><br><span class="line">&#125;</span><br><span class="line">var a = 1</span><br><span class="line">foo.call(null)</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>

<p>解决方法：⭐创建一个特殊的空对象，作为this的占位符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的 DMZ 空对象 </span></span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组展开成参数 </span></span><br><span class="line">foo.apply(ø, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind(..) 进行柯里化 </span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(ø, <span class="number">2</span>);</span><br><span class="line">bar(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure>

<h5 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h5><p>bind(), 硬绑定之后无法使用隐式或显示绑定修改this（除了new）</p>
<p>⭐softbind()，绑定之后还可以用隐式或者显示绑定修改this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span>; <span class="comment">// 捕获所有 curried 参数         </span></span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">                (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global)) ? </span><br><span class="line">                obj : <span class="keyword">this</span> </span><br><span class="line">                curried.concat.apply(curried, <span class="built_in">arguments</span>));</span><br><span class="line">            &#125;;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;      <span class="keyword">return</span> bound;      &#125;; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决 定 this。所以箭头函数的this是在创建词法作用域的时候就确定了。</p>
<p>箭头函数常用于回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 这里的 this 在此法上继承自 foo()         </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li><p>四条规则判断this绑定的对象</p>
</li>
<li><p>foo.apply(null) 使用null作为this占位符</p>
<p>foo.apply( ø ), 更安全的忽略this绑定的方式，使用DMZ对象，</p>
<p>ø = Object.create(null)</p>
</li>
<li><p>箭头函数的this绑定，取决于外层词法作用域，箭头函数会继承外层函数调用的this绑定</p>
</li>
</ul>
<h4 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>定义对象的两种形式<ul>
<li>声明形式  {key:value}</li>
<li>构造形式  new obj()</li>
</ul>
</li>
</ul>
<h5 id="javascript-类型（6钟）"><a href="#javascript-类型（6钟）" class="headerlink" title="javascript 类型（6钟）"></a>javascript 类型（6钟）</h5><ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null  (注：typeof null  //object，这是语言本身的一个bug)</li>
<li>undefined </li>
<li>object</li>
</ul>
<blockquote>
<p>typeof null 的原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型， null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。 </p>
</blockquote>
<h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>对于原始值string，number，boolean调用方法，默认会将原始值转换为对应内置对象，获取的是内置对象上的方法和属性。</p>
<h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p>对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的。</p>
<ul>
<li>这些值并没有被存储在对象钟，这只是一种表现形式</li>
<li>实际上，对象的属性就像指针（从技术角度讲就是引用），指向这些值真正的存储位置</li>
</ul>
<p>读取属性的方式</p>
<ul>
<li>.a      (属性名需要满足变量的命名规范)</li>
<li>[“a”] （[..]里面的内容会被当做表达式求值）</li>
</ul>
<p>⭐注意</p>
<p>在对象中，<strong>属性名永远是都是字符串</strong>。如果你使用string（字面量）以外的其他值作为属性名，那么它首先会被转换为一个字符串</p>
<h5 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h5><p>方法：实际上，函数永远不会“属于”一个对象，只不过是对函数的一种引用，通过obj.foo()调用时，this会动态绑定为obj</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>myArray = [“foo”,”bar”，42]，数组期望的下标为数值</p>
<ul>
<li><p>当你通过 myArray.baz = “baz” ,虽然myArray上多了一个命名属性baz，但实际上数组的长度仍然没有发生变化</p>
</li>
<li><p>如果属性名看起来是一个数字，那它就会变成一个数值下标</p>
<p>myArray[“3”] = “baz” ，数组多了一个元素</p>
</li>
</ul>
<h5 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h5><p>关于复制对象分为两种情况  a = {code：1 ，person： {name: tom, age: 18}}</p>
<ul>
<li>浅拷贝 ： shallowCopy(a) ,  简单的属性和数组值的复制，对于person只是一种对象的引用，并没有重新创建一个新的person对象</li>
<li>深拷贝：deepCopy(a)，而对于深拷贝来说，不再是引用原有的对象，而是重新创建一个新的person对象</li>
</ul>
<p>⭐循环引用的问题</p>
<p>关于复制对象的方法</p>
<ul>
<li>var newObj = JSON.parse( JSON.stringify( someObj ) ); 只适用于部分情况</li>
<li>var newObj = Object.assign( {}, myObject );  浅拷贝</li>
<li>lodash，deepClone</li>
</ul>
<h5 id="Object的特性"><a href="#Object的特性" class="headerlink" title="Object的特性"></a>Object的特性</h5><ul>
<li><p>属性描述符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;     </span><br><span class="line">	value: <span class="number">2</span>,     </span><br><span class="line">	writable: <span class="literal">true</span>,      </span><br><span class="line">	configurable: <span class="literal">true</span>,      </span><br><span class="line">	enumerable: <span class="literal">true</span> </span><br><span class="line"> &#125; );</span><br></pre></td></tr></table></figure>

<ul>
<li>Writable ： 是否可以修改属性的值</li>
<li>Configurable  ： 是否可配置，可以使用 defineProperty(..) 方法来修改属性描述符</li>
<li>Enumerable ：是否可枚举</li>
</ul>
</li>
<li><p>不变性，浅不变性(只影响目标对象的和它的直接属性，如果目标对象引用了其他对象，其他对象的内容还是可变的)</p>
<ul>
<li>writable:false ， configurable:false  ： 不可修改，重定义或者删除</li>
<li>Object.preventExtensions( ) ： 禁止扩展</li>
<li>Object.seal(..)  ： 这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false</li>
<li>Object.freeze(..) ： 这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值。</li>
</ul>
</li>
</ul>
<h5 id="⭐内部属性"><a href="#⭐内部属性" class="headerlink" title="⭐内部属性"></a>⭐内部属性</h5><p>[[Get]] ： 用来读取属性的值</p>
<ul>
<li>在obj.a读取属性a的值时，实际上时使用了[[Get]]操作（有点像函数调 用：[[Get]] ()）。</li>
<li>对象默认的内置[[Get]]操作首先在对象钟查找是否由名称相同的属性，如果找到就会返回这个属性的值。</li>
<li>如果没有找到，就会遍历可能存在的原型链。</li>
<li>如果无论如何都没有找到名称相同的属性，那么会返回undefined</li>
</ul>
<p>[[Put]] :  用来设置或者创建这个属性 obj.a = “a”</p>
<ul>
<li><p>是否已经存在该属性？</p>
</li>
<li><p>属性存在</p>
<ul>
<li><p>是否由访问描述符 （setter），如果由就调用setter</p>
</li>
<li><p>数据描述符的writtable 是否为false</p>
</li>
<li><p>如果都不是，将该值设置为属性的值</p>
</li>
</ul>
</li>
</ul>
<h5 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h5><p>在es5中可以用getter和setter部分改写默认操作，但是只能应用在单个属性中，无法应用在整个对象上。</p>
<ul>
<li>获取属性值，会调用getter函数</li>
<li>设置属性值，会调用setter函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="comment">// 给 a 定义一个 getter    </span></span><br><span class="line">    <span class="keyword">get</span> a() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 a 定义一个 setter     </span></span><br><span class="line">    <span class="keyword">set</span> a(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">myObject.a; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h5 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h5><p>读取属性结果为undefined有两种可能</p>
<ul>
<li>属性值为undefined</li>
<li>没有这个属性，返回undefined</li>
</ul>
<p>如何区别这两种可能？</p>
<ul>
<li><p>“a” in myObject</p>
</li>
<li><p>myObject.hasOwnProperty( “a” )</p>
</li>
</ul>
<h5 id="枚举和遍历"><a href="#枚举和遍历" class="headerlink" title="枚举和遍历"></a>枚举和遍历</h5><p>条件 ： 是否在原型链上查找，是否包括不可枚举属性</p>
<ul>
<li><p>for…in</p>
<ul>
<li>在整个原型链上遍历属性</li>
<li>只包括可枚举属性</li>
</ul>
</li>
<li><p>hasOwnProperty(..)</p>
<ul>
<li>只查找对象是否包含某属性</li>
<li>包括可枚举和不可枚举的属性</li>
</ul>
</li>
<li><p>Object.keys(..)</p>
<ul>
<li>只在当前对象中查找</li>
<li>返回一个数组，包含所有可枚举属性</li>
</ul>
</li>
<li><p>Object.getOwnPropertyNames(..)</p>
<ul>
<li>只在当前对象中插嘴</li>
<li>返回一个数组，包含了所有属性（包括可枚举和不可枚举）</li>
</ul>
</li>
<li><p>⭐for .. of ： 用来遍历数组元素值</p>
<p>原理 ： 使用迭代器对象，通过调用得带起对象的next（）方法来遍历所有的返回值</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//使用Symbol.iterator 来获取对象的 @@iterator 内部属性</span></span><br><span class="line"><span class="comment">// @@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数</span></span><br><span class="line"><span class="keyword">var</span> it = myArray[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:1, done:false &#125;  </span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;  </span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;  </span></span><br><span class="line">it.next(); <span class="comment">// &#123; done:true &#125;</span></span><br></pre></td></tr></table></figure>

<p>注： 因为普通的对象没有内置的 @@iterator，所以无法使用for ..of遍历，但是我们也可以给任何想遍历对象定时 @@iterator</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li><p>js数据类型</p>
<ul>
<li>基础类型</li>
<li>引用类型</li>
</ul>
</li>
<li><p>对象就是键/值对的集合</p>
</li>
<li><p>对象的属性描述符</p>
</li>
<li><p>for .. of遍历数据结构中的值，，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值</p>
</li>
</ul>
<h4 id="第四章-混合对象“类”"><a href="#第四章-混合对象“类”" class="headerlink" title="第四章 混合对象“类”"></a>第四章 混合对象“类”</h4><p>类是一种可选的设计模式</p>
<h5 id="类的机制"><a href="#类的机制" class="headerlink" title="类的机制"></a>类的机制</h5><p>在面向类的语言中，“标准库”会提供Stack类，但是stack类不是’栈‘，它仅仅是一个抽象的表示，你必须先实例化stack类然后才能对它进行操作</p>
<h5 id="建造"><a href="#建造" class="headerlink" title="建造"></a>建造</h5><p>类和实例的概念来自于房屋建造</p>
<ul>
<li>类 = 建筑蓝图</li>
<li>实例化 = 按照蓝图来建造 一个东西</li>
</ul>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>new Foo() , 通过调用构造函数来生成一个实例</p>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>在面向对象的语言中，多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同实列而执行不同操作</p>
<p><img src="/2019/11/24/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%EF%BC%89this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/%E7%B1%BB.png" alt="类"></p>
<ul>
<li><p>super：在子类中相对引用它继承的父类</p>
<ul>
<li>相对：继承的基础上，可以进行改写</li>
</ul>
</li>
<li><p>多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是 复制。</p>
</li>
</ul>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p><img src="/2019/11/24/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%EF%BC%89this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/%E5%A4%9A%E6%80%81.png" alt="多态"></p>
<h5 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h5><p>在其他语言中，类表现除的都是复制行为，子类得到的只是父类的一份副本</p>
<p>而js中只有对象（引用类型），对象并不会被复制到其他对象中，而是被引用</p>
<ul>
<li>显示混入</li>
<li>隐式混入<ul>
<li>（OtherObj.methodName.call(this, …)</li>
</ul>
</li>
</ul>
<h4 id="第五章-原型"><a href="#第五章-原型" class="headerlink" title="第五章 原型"></a>第五章 原型</h4><h5 id="Prototype-：内置属性"><a href="#Prototype-：内置属性" class="headerlink" title="[[Prototype]]：内置属性"></a>[[Prototype]]：内置属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funtion Foo() &#123;&#125;</span><br><span class="line">var foo = new Foo()</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf( foo ) === Foo.prototype; // true</span><br></pre></td></tr></table></figure>

<p>Foo是一个函数，每个函数都有一个特殊的属性prototype，它指向一个对象</p>
<p>每个对象都有一个内置属性 – [[Prototype]]，通过new实例化一个foo对象，foo对象中有一个[[Prototype]]指向了</p>
<p>Foo.prototype对象。</p>
<ul>
<li>有别于其他语言中的类中的继承（完全复制一份），js中的原型继承，只是在对象加入一个特殊的指针，与其他对象进行关联。</li>
</ul>
<h5 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h5><p>设置</p>
<ul>
<li>沿着原型链寻找是否存在该属性（writeable: true）<ul>
<li>如果找到，将值赋值给第一个遍历到的属性</li>
<li>如果没找到，直接在当前对象中创建属性</li>
</ul>
</li>
</ul>
<p>屏蔽</p>
<ul>
<li>如果当前对象的属性，在原型链上也有该属性<ul>
<li>则原型上层属性会被屏蔽，只读取当前对象的属性</li>
</ul>
</li>
</ul>
<h5 id="⭐“构造函数”"><a href="#⭐“构造函数”" class="headerlink" title="⭐“构造函数”"></a>⭐“构造函数”</h5><p><strong>构造函数</strong>，其实就是一个普通的调用，只是在通过new 调用整个函数，会创建一个新对象并返回（如果函数本身并没有return语句），在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">funtion Foo() &#123;&#125;</span><br><span class="line">var foo = new Foo()</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf( foo ) === Foo.prototype; // true</span><br><span class="line">Foo.prototype.constructor === Foo  //true</span><br><span class="line">foo.constructor === Foo  //true</span><br><span class="line">foo.hasOwnProperty(constructor)  //false</span><br></pre></td></tr></table></figure>

<ul>
<li>Foo.prototype 默认有一个公有并且不可枚举 的属性 .constructor，这个属性引用的是对象关联的函数</li>
<li>foo其实本身并不存在constructor属性，foo.constructor === Foo 为什么等于true，其实是因为foo.constructor引用了Foo.prototype.constructor（机制：前面的原型链查找）</li>
</ul>
<p>⭐是否是Foo构造了foo？</p>
<p>好吧，原来之前的理解有问题。看了书对原型好像开始有了新的理解。</p>
<ul>
<li><p>所谓的构造函数，并存在特殊的“构造函数”，无非还是普通的函数调用，只是在前面加上了一个new，new 会劫持所有普通函数并用构造对象的形式来调用它（本值上其实函数还是在被调用，只是隐藏了部分操作，只通过new这一个关键词代表了这部分操作）</p>
</li>
<li><p>js中的原型，其实就是一种关联机制，通过一个特殊指针引用对象，然后通过指针引用形成链（有点类似与数据结构中的单向链表）</p>
</li>
<li><p>foo.constructor === Foo，并不能解释为foo是有Foo构造的，其实foo这个对象不过是用[[Prototype]]与Foo.prototype对象关联起来，通过原型链查找，在Foo.prototype对象上找到了constructor属性，如果Foo.prototype对象上没有constructor属性，它还会沿着原型链继续向上查找</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* .. */</span> &#125; </span><br><span class="line"> </span><br><span class="line">Foo.prototype = &#123; <span class="comment">/* .. */</span> &#125;; <span class="comment">// 创建一个新原型对象 ，该对象中没有添加constructor属性</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line">foo.constructor === Foo; <span class="comment">// false!  </span></span><br><span class="line">foo.constructor === <span class="built_in">Object</span>; <span class="comment">// true!</span></span><br></pre></td></tr></table></figure>

<p>修复constructor属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* .. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">    <span class="comment">/* .. */</span></span><br><span class="line">&#125;; <span class="comment">// 创建一个新原型对象 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性 </span></span><br><span class="line"><span class="comment">// 新对象属性起到 Foo.prototype 的作用 </span></span><br><span class="line"><span class="comment">// 关于 defineProperty(..)，参见第 3 章</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Foo.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: Foo</span><br><span class="line">    <span class="comment">// 让 .constructor 指向 Foo </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="⭐原型继承"><a href="#⭐原型继承" class="headerlink" title="⭐原型继承"></a>⭐原型继承</h5><p> Bar.prototype = Object.create( Foo.prototype ) </p>
<ul>
<li>调用 Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo.prototype）</li>
<li>指向一个新对象的好处是，执行Bar.prototype. myLabel = …，只会修改空对象的属性，而不会修改Foo.prototype对象</li>
</ul>
<p>Bar.prototype = Foo.prototype （这种形式会产生一些问题）</p>
<ul>
<li>并不会创建一个关联到 Bar.prototype 的新对象，它只 是让Bar.prototype 直接引用 Foo.prototype 对象。</li>
<li>当你执行类似 Bar.prototype. myLabel = … 的赋值语句时会直接修改 Foo.prototype 对象本身</li>
</ul>
<p>Bar.prototype = new Foo()</p>
<ul>
<li><p>虽然会创建一个关联到 Bar.prototype 的新对象，如果函数Foo不是空函数，有一些副作用会影响，可能会通过过this的方式添加到Bar.prototype 上，这样不仅继承了Foo的原型，还添加了别的属性，影响Bar的后代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">	this.other = &quot;side effect&quot;  //原型对象上会添加other属性</span><br><span class="line">&#125; </span><br><span class="line">//实例化</span><br><span class="line">var Bar.prototype  = new Foo();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Foo是空函数就不影响了</p>
</li>
</ul>
<h5 id="es6之后出现的新方法"><a href="#es6之后出现的新方法" class="headerlink" title="es6之后出现的新方法"></a>es6之后出现的新方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 之前需要抛弃默认的 Bar.prototype </span></span><br><span class="line">Bar.ptototype = <span class="built_in">Object</span>.create( Foo.prototype ); </span><br><span class="line">=&gt;类似于</span><br><span class="line">Bar.ptototype = &#123;&#125; (&#123;&#125;._proto = Foo.prototype)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ES6 开始可以直接修改现有的 Bar.prototype =&gt; 来修改对象的 [[Prototype]] 关联 </span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br><span class="line">=&gt; 相当于</span><br><span class="line">Bar.prototype._proto = Foo.prototype <span class="comment">//.__proto__ 属性非标准无法兼容</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h5 id="检查类的关系"><a href="#检查类的关系" class="headerlink" title="检查类的关系"></a>检查类的关系</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;      // ... &#125; </span><br><span class="line">  </span><br><span class="line">var a = new Foo();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>a instanceof Foo</p>
<ul>
<li>在 a 的整条 [[Prototype]] 链中是否有指向 Foo.prototype 的对象？</li>
<li>只能处理对象（a) 和‘构造函数’( Foo )之间的关系</li>
</ul>
</li>
<li><p>Foo.prototype.isPrototypeOf( a )  =&gt;  b.isPrototypeOf( c )</p>
<ul>
<li>在 a 的整 条 [[Prototype]] 链中是否出现过 Foo.prototype ？</li>
<li>可以判断两个对象之间的关系</li>
</ul>
</li>
<li><p>Object.getPrototypeOf( a ) === Foo.prototype</p>
<ul>
<li>getPrototypeOf可以获取一个对象的[[Prototype]] 链</li>
</ul>
</li>
</ul>
<h5 id="⭐总结（就copy书本上的文字把-，这一章介绍的角度确实很深刻）"><a href="#⭐总结（就copy书本上的文字把-，这一章介绍的角度确实很深刻）" class="headerlink" title="⭐总结（就copy书本上的文字把~，这一章介绍的角度确实很深刻）"></a>⭐总结（就copy书本上的文字把~，这一章介绍的角度确实很深刻）</h5><p>如果要访问对象中并不存在的一个属性，[[Get]] 操作（参见第 3 章）就会查找对象内部 [[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”（有点像嵌套的作用域链），在查找属性时会对它进行遍历。<br><strong>所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如 果在原型链中找不到指定的属性就会停止。</strong>toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。<br>关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤（第 2 章）中会创建一个关联其他对象的新对象。<br>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象” 。带 new 的函数调用 通常被称为“构造函数调用” ，尽管它们实际上和传统面向类语言中的类构造函数不一样。<br>虽然这些 JavaScript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但 是 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。<br>出于各种原因，以“继承”结尾的术语（包括“原型继承”）和其他面向对象的术语都无 法帮助你理解 JavaScript 的真实机制（不仅仅是限制我们的思维模式）。<br>相比之下，“委托”是一个更合适的术语，因为<font color="LightCoral"><strong>对象之间的关系不是复制而是委托</strong></font></p>
<h5 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h5><ul>
<li>只要是对象，就有一个内部属性[[prototype]]</li>
<li>只要是函数，就有一个特殊的属性prototype，指向一个原型对象<ul>
<li>该原型对象也是一个对象，内部也有[[prototyoe]]属性，指向另一个对象（串着串着…就产生了原型链）</li>
</ul>
</li>
<li>var foo = new Foo() <ul>
<li>new 操作符，就是通过实例化，创建新对象，然后将新创建的对象的[[prototype]]属性与Foo.prototyoe对象关联</li>
</ul>
</li>
</ul>
<h4 id="第六章-行为委托"><a href="#第六章-行为委托" class="headerlink" title="第六章 行为委托"></a>第六章 行为委托</h4><p>[[prototype]]机制就是指对象中一个内部链接引用另一个对象</p>
<p>如果在第一个对象上没有找到需要的属性或者方法引用，引擎会继续在[[prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p>
<p>换句话说，javascript中这个机制的本质就是对象之间的关联关系。</p>
<hr>
<p><strong><font color="LightCoral">一些委托和“继承”的语法差异</font></strong></p>
<ul>
<li><p>js中的class语法糖,用super-继承父类属性和方法</p>
<ul>
<li>super（width，height） ：相当于 parent.call( this, width, height );<ul>
<li>执行parent函数，this绑定为child，将属性挂载到child对象上</li>
</ul>
</li>
</ul>
</li>
<li><p>关于对象委托和“原型继承”代码风格的差异</p>
<ul>
<li>对象委托，重点是关联两个对象 （讨论的是两个对象的关系）<ul>
<li>属性写在对象的init函数中</li>
<li>方法也写在对象中</li>
</ul>
</li>
<li>原型“继承”，关联的是构造函数的[[prototype]]对象 （讨论的是三者之间的关系）<ul>
<li>属性放在构造函数中（通过parent.call(this,attrName)继承）</li>
<li>方法放在构造函数的prototype对象上（通过原型链访问）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>参考</strong></p>
<p>《你不知道的js》</p>
<p> <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a> </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/" rel="tag"># 你不知道的js</a>
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%EF%BC%89-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/" rel="next" title="你不知道的js（上）- 作用域和闭包">
                <i class="fa fa-chevron-left"></i> 你不知道的js（上）- 作用域和闭包
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/03/git%E8%AE%BE%E7%BD%AEssh/" rel="prev" title="git设置ssh">
                git设置ssh <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="lory" />
            
              <p class="site-author-name" itemprop="name">lory</p>
              <p class="site-description motion-element" itemprop="description">(●'◡'●)</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lory02" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一章-关于this"><span class="nav-number">1.</span> <span class="nav-text">第一章 关于this</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#this绑定的4种情况"><span class="nav-number">1.1.</span> <span class="nav-text">this绑定的4种情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优先级"><span class="nav-number">1.2.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#被忽略的this"><span class="nav-number">1.3.</span> <span class="nav-text">被忽略的this</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#软绑定"><span class="nav-number">1.4.</span> <span class="nav-text">软绑定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#箭头函数"><span class="nav-number">1.5.</span> <span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三章-对象"><span class="nav-number">2.</span> <span class="nav-text">第三章 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#语法"><span class="nav-number">2.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#javascript-类型（6钟）"><span class="nav-number">2.2.</span> <span class="nav-text">javascript 类型（6钟）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内置对象"><span class="nav-number">2.3.</span> <span class="nav-text">内置对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内容"><span class="nav-number">2.4.</span> <span class="nav-text">内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性与方法"><span class="nav-number">2.5.</span> <span class="nav-text">属性与方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组"><span class="nav-number">2.6.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#复制对象"><span class="nav-number">2.7.</span> <span class="nav-text">复制对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object的特性"><span class="nav-number">2.8.</span> <span class="nav-text">Object的特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#⭐内部属性"><span class="nav-number">2.9.</span> <span class="nav-text">⭐内部属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Getter和Setter"><span class="nav-number">2.10.</span> <span class="nav-text">Getter和Setter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#存在性"><span class="nav-number">2.11.</span> <span class="nav-text">存在性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#枚举和遍历"><span class="nav-number">2.12.</span> <span class="nav-text">枚举和遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结-1"><span class="nav-number">2.13.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第四章-混合对象“类”"><span class="nav-number">3.</span> <span class="nav-text">第四章 混合对象“类”</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类的机制"><span class="nav-number">3.1.</span> <span class="nav-text">类的机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#建造"><span class="nav-number">3.2.</span> <span class="nav-text">建造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数"><span class="nav-number">3.3.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#继承"><span class="nav-number">3.4.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多态"><span class="nav-number">3.5.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多重继承"><span class="nav-number">3.6.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#混入"><span class="nav-number">3.7.</span> <span class="nav-text">混入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第五章-原型"><span class="nav-number">4.</span> <span class="nav-text">第五章 原型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Prototype-：内置属性"><span class="nav-number">4.1.</span> <span class="nav-text">[[Prototype]]：内置属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性设置和屏蔽"><span class="nav-number">4.2.</span> <span class="nav-text">属性设置和屏蔽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#⭐“构造函数”"><span class="nav-number">4.3.</span> <span class="nav-text">⭐“构造函数”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#⭐原型继承"><span class="nav-number">4.4.</span> <span class="nav-text">⭐原型继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#es6之后出现的新方法"><span class="nav-number">4.5.</span> <span class="nav-text">es6之后出现的新方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检查类的关系"><span class="nav-number">4.6.</span> <span class="nav-text">检查类的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#⭐总结（就copy书本上的文字把-，这一章介绍的角度确实很深刻）"><span class="nav-number">4.7.</span> <span class="nav-text">⭐总结（就copy书本上的文字把~，这一章介绍的角度确实很深刻）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#概括"><span class="nav-number">4.8.</span> <span class="nav-text">概括</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第六章-行为委托"><span class="nav-number">5.</span> <span class="nav-text">第六章 行为委托</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lory</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
